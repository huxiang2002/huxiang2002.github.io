<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>上海交通大小考研机试——大数运算</title>
      <link href="/2023/08/04/shang-hai-jiao-tong-da-xiao-kao-yan-ji-shi-da-shu-yun-suan/"/>
      <url>/2023/08/04/shang-hai-jiao-tong-da-xiao-kao-yan-ji-shi-da-shu-yun-suan/</url>
      
        <content type="html"><![CDATA[<h3 id="上海交通大学考研机试——大数运算"><a href="#上海交通大学考研机试——大数运算" class="headerlink" title="上海交通大学考研机试——大数运算"></a>上海交通大学考研机试——大数运算</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个整数 $a$ 和 $b$，请你依次计算并输出 $a+b$、$a−b$、$a×b$ 的结果。</p><p>注意：$a,b$ 不含前导零。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 $a$。</p><p>第二行包含整数 $b$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出 $a+b$ 的结果。</p><p>第二行输出 $a−b$ 的结果。</p><p>第三行输出 $a×b$ 的结果。</p><p>数据范围<br>$|a|$,$|b|$ &lt; $10^{400}$</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre class="line-numbers language-none"><code class="language-none">200000000000000004000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><pre class="line-numbers language-none"><code class="language-none">240000000000000001600000000000000080000000000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>从题目的数据范围可以看出我们需要使用高精度算法，分别是：高精度加法，高精度*高精度，高精度/低精度<br>读者若对以上算法不熟悉可以将对应代码模拟一遍，背过即可<br>此题的考察的算法不难。不过需要考察正负号的问题<br>我们可以使用substr函数将读入的字符串从1到末尾截取下来<br>用na,nb保存我们的数字的正负号，可以将情况分为两大类<br>1、符号相同<br>2、符号相反<br>具体情况看代码注释</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int cmp(vector&lt;int&gt; A,vector&lt;int&gt; B)//比较函数{    if(A.size()&lt;B.size()) return -1;    if(A.size()&gt;B.size()) return 1;    for(int i=A.size()-1;i&gt;=0;i--)        if(A[i]&lt;B[i]) return -1;        else if(A[i]&gt;B[i]) return 1;    return 0;}vector&lt;int&gt; add(vector&lt;int&gt; A,vector&lt;int&gt; B)//加法模板{    vector&lt;int&gt; C;    int t=0;    for(int i=0;i&lt;A.size()||i&lt;B.size()||t;i++)    {        if(i&lt;A.size()) t+=A[i];        if(i&lt;B.size()) t+=B[i];        C.push_back(t%10);        t/=10;    }    return C;}vector&lt;int&gt; sub(vector&lt;int&gt; A,vector&lt;int&gt; B)//减法模板{    vector&lt;int&gt; C;    int t=0;    for(int i=0;i&lt;A.size();i++)    {        t=A[i]-t;        if(i&lt;B.size()) t-=B[i];        C.push_back((t+10)%10);        if(t&lt;0) t=1;        else t=0;    }    while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();    return C;}vector&lt;int&gt; mul(vector&lt;int&gt; A,vector&lt;int&gt; B)//乘法模板{    int t=0;    vector&lt;int&gt; C(A.size()+B.size(),0);    for(int i=0;i&lt;A.size();i++)        for(int j=0;j&lt;B.size();j++)            C[i+j]+=A[i]*B[j];    for(int i=0;i&lt;C.size();i++)    {        t+=C[i];        C[i]=t%10;        t/=10;    }    while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();    return C;}void print(vector&lt;int&gt; A)//输出{    for(int i=A.size()-1;i&gt;=0;i--) cout&lt;&lt;A[i];    cout&lt;&lt;endl;}int main(){    string a,b;    cin&gt;&gt;a&gt;&gt;b;    int na=1,nb=1;    if(a[0]=='-') na=-1,a=a.substr(1);//用substr扣掉符号    if(b[0]=='-') nb=-1,b=b.substr(1);    vector&lt;int&gt; A,B;    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-'0');    for(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-'0');    if(na*nb&gt;0)//如果两个符号相同    {        if(na&lt;0) cout&lt;&lt;"-";//na&lt;0 nb也&lt;0 相加为"-"        print(add(A,B));        bool has_swap=false;//记录是否交换        if(cmp(A,B)&lt;0)//B较大        {            has_swap=true;//交换            swap(A,B);            swap(na,nb);        }        auto C=sub(A,B);//做减法        if(na&gt;0&amp;&amp;has_swap||na&lt;0&amp;&amp;!has_swap)        //第一种情况:两数都大于0 且交换则B较大 A-B&lt;0        //第二种情况:两数都小于0 且不交换说明去掉符号的A更大则A-B&lt;0        {            if(C.size()&gt;1||C[0]&gt;0)//不为0                cout&lt;&lt;"-";        }        print(C);        print(mul(A,B));    }    else   //符号相反    {        bool has_swap=false;//记录是否交换        if(cmp(A,B)&lt;0)//B去掉符号更大交换        {            has_swap=true;            swap(A,B);            swap(na,nb);        }        auto C=sub(A,B);//A+B AB符号为异号 加法变为减法        if(na&lt;0&amp;&amp;(C.size()&gt;1||C[0]&gt;0)) cout&lt;&lt;"-";//na&lt;0 nb&gt;0且C不为0        //第一种情况A&gt;0 B&lt;0 且B的绝对值这时交换位置 |B|-A为正数实际A+B为负数        //第二种情况A&lt;0 B&gt;0 且B的绝对值更小不交唤|A|-B为正数实际A+B为负数        print(sub(A,B));        if(na&gt;0&amp;&amp;has_swap||na&lt;0&amp;&amp;!has_swap) cout&lt;&lt;"-";        //na&gt;0 nb&lt;0 且发生交换原来是na&lt;0,nb&gt;0的减法且|B|较大差为负数。现在为绝对值较大的正数B+|A|        //na&lt;0 nb&gt;0 且不发生交换原来是na&lt;0,nb&gt;0的减法且|A|较大差为负数，现在为|A|+B        print(add(A,B));//符号相反的减法可变为加法        if(a!="0"&amp;&amp;b!="0") cout&lt;&lt;"-";//a,b都不为0        print(mul(A,B));    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
